<?php

/**
 * @file
 * This file contains the shared functions between dt_core and cwt_core.
 */

/**
 * No source field Exception.
 */
class DtSharedFunctionsSourceFieldError extends Exception {
}

/**
 * No destionation field Exception.
 */
class DtSharedFunctionsDestinationFieldError extends Exception {
}

/**
 * Fields are of same tye Exception.
 */
class DtSharedFunctionsFieldTypeAreNotSame extends Exception {
}

/**
 * Circular reference Exception.
 */
class DtSharedFunctionsParentCircular extends Exception {
}

include_once 'dt_shared_functions.accessibility.inc';

/**
 * Implements hook_init().
 */
function dt_shared_functions_init() {
  if ($node = menu_get_object()) {
    $available_languages = language_list('prefix');
    $content_language_code = _dt_shared_functions_content_language($node);
    $GLOBALS['language_content'] = isset($available_languages[$content_language_code]) ? $available_languages[$content_language_code] : $GLOBALS['language_content'];
  }
}

/**
 * Implements hook_views_api().
 */
function dt_shared_functions_views_api() {
  return ['api' => 3.0];
}

/**
 * Implements hook_views_plugins().
 */
function dt_shared_functions_views_plugins() {
  return [
    'display_extender' => [
      'dt_shared_views_config' => [
        'title' => t('Digital Transformation config'),
        'handler' => 'views_plugin_dt_shared_functions_views_config',
        'enabled' => TRUE,
      ],
    ],
  ];
}

/**
 * Custom function returning additional views configuration.
 *
 * @return array
 *   Array of extra settings for views.
 */
function _dt_shared_functions_additional_views_config() {
  $settings = [
    'dt_shared_functions_views_config_title' => [
      '#title' => t('Title'),
      '#type' => 'textfield',
      '#description' => t('The title to display in the counter result.'),
      '#required' => FALSE,
    ],
  ];

  drupal_alter('dt_shared_functions_views_config', $settings);

  return $settings;
}

/**
 * Implements hook_token_info().
 *
 * Here we define our token "group" so we do not have to define it anymore in
 * the handlers.
 */
function dt_shared_functions_token_info() {
  $info['types'][_dt_shared_function_get_token_type()] = array(
    'name' => t('Dt tokens'),
    'description' => t('Dt custom tokens'),
  );
  return $info;
}

/**
 * Helper function to return the token group.
 *
 * We predefine this in a helper so that we can use it in multiple files, and in
 * case it ever changes, we can do it in a centralized location.
 *
 * @return string
 *   The name of the token group we use.
 */
function _dt_shared_function_get_token_type() {
  return 'dt_tokens';
}

/**
 * Implements hook_nexteuropa_token_token_handlers().
 */
function dt_shared_functions_nexteuropa_token_token_handlers() {
  return array(
    'language_handler' => '\Drupal\dt_shared_functions\LanguageTokenHandler',
    'publish_date_handler' => '\Drupal\dt_shared_functions\PublishdateTokenHandler',
    'update_date_handler' => '\Drupal\dt_shared_functions\UpdatedateTokenHandler',
  );
}

/**
 * Implements hook_nexteuropa_token_token_handlers_alter().
 */
function dt_shared_functions_nexteuropa_token_token_handlers_alter(array &$handlers) {
  $handlers['url_entity_handler'] = '\Drupal\dt_shared_functions\DtUrlTokenHandler';
}

/**
 * Implements hook_translated_menu_link_alter().
 */
function dt_shared_functions_translated_menu_link_alter(&$item, $map) {
  global $language;
  $tokenize = isset($item['options']['menu_token_data']['node']['options']['id']);

  if ($tokenize) {
    $nid = $item['options']['menu_token_data']['node']['options']['id'];
    $data['node'] = entity_load_single('node', $nid);
    // This should be done by the token_menu module, actually.
    $options['language'] = $language;
    $item['link_title'] = token_replace($item['title'], $data, $options);
  }
}

/**
 * Helper function to delete menu, menu links, taxonomies.
 *
 * @param string $name
 *   The name item.
 * @param string $type
 *   The type of the item.
 * @param string $op
 *   The operation to execute.
 */
function _dt_shared_functions_delete($name, $type = 'menu', $op = 'items') {
  switch ($type) {
    case 'menu':
      if ($op == 'items') {
        menu_delete_links($name);
      }
      else {
        menu_delete(array('menu_name' => $name));
      }
      break;

    case 'vocabulary':
      if ($op == 'items') {
        $voc = taxonomy_vocabulary_machine_name_load($name);
        if (!empty($voc)) {
          $terms = taxonomy_get_tree($voc->vid);
          foreach ($terms as $term) {
            taxonomy_term_delete($term->tid);
          }
        }
      }
      else {
        $voc = taxonomy_vocabulary_machine_name_load($name);
        if (!empty($voc)) {
          taxonomy_vocabulary_delete($voc->vid);
        }
      }
      break;

    case 'node':
      $node_type = array($name);
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->propertyCondition('type', $node_type, 'IN');
      $result = $query->execute();
      foreach ($result['node'] as $node) {
        node_delete($node->nid);
      }
      break;
  }
}

/**
 * Implements hook_facetapi_facet_info_alter().
 *
 * This modification is required for using the database search. If we are not
 * doing this, errors will appear.
 */
function dt_shared_functions_facetapi_facet_info_alter(array &$facet_info, array $searcher_info) {
  if (!isset($facet_info['bundle']['name'])) {
    unset($facet_info['bundle']);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters the exposed form to include some additional logic.
 */
function dt_shared_functions_form_views_exposed_form_alter(&$form, &$form_state) {
  if (!$form_state['submitted']) {
    // Hide the button, but only when js is available.
    if (isset($form['reset']) && !empty($form['reset'])) {
      $form['reset']['#attributes']['class'][] = 'js-hide';
      $form['reset']['#attributes']['class'][] = 'js-showonsubmit';
    }
  }
}

/**
 * Implements hook_ajax_render_alter().
 *
 * Hide the showonsubmit button after the ajax request.
 */
function dt_shared_functions_ajax_render_alter(&$commands) {
  $commands[] = ajax_command_invoke('.js-showonsubmit', 'show');
}

/**
 * Copy values from source to destination filed.
 *
 * @param string $entity_type
 *   The type of entity, like: node.
 * @param string $bundle
 *   Entity bundle, like: page.
 * @param string $source_field_name
 *   Source field name, like: field_core_link.
 * @param string $destination_field_name
 *   Destination field, like: field_core_links.
 * @param bool $append
 *   If we should append or replace.
 * @param bool $clear
 *   If true, then the old value will be set empty.
 *
 * @throws \DtSharedFunctionsSourceFieldError
 *   Exception when no source field with the given name.
 * @throws \DtSharedFunctionsDestinationFieldError
 *   Exception when no destination field with the given name.
 * @throws \DtSharedFunctionsFieldTypeAreNotSame
 *   Exception when source and destination are not the same field type.
 */
function _dt_shared_field_value_copy($entity_type, $bundle, $source_field_name, $destination_field_name, $append = FALSE, $clear = FALSE) {
  // Source and destination field info.
  $source_field_info = field_info_field($source_field_name);
  $destination_field_info = field_info_field($destination_field_name);

  // Error handling.
  if (!$source_field_info) {
    throw new DtSharedFunctionsSourceFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $source_field_name,
      ))
    );
  }
  if (!$destination_field_info) {
    throw new DtSharedFunctionsDestinationFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $destination_field_name,
      ))
    );
  }
  if ($source_field_info['type'] != $destination_field_info['type']) {
    throw new DtSharedFunctionsFieldTypeAreNotSame(
      t('%source (source) and %destination (destination) are not the same field type.', array(
        '%source' => $source_field_name,
        '%destination' => $destination_field_name,
      ))
    );
  }
  // Source field  is a multiple one.
  $source_field_is_multiple = ($source_field_info['cardinality'] != 1) ? TRUE : FALSE;
  // Destination field is a multiple one.
  $destination_field_is_multiple = ($destination_field_info['cardinality'] != 1) ? TRUE : FALSE;

  // Query the entities.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $bundle);
  $result = $query->execute();

  // Use the result if any.
  if (isset($result[$entity_type])) {
    // Get the entity ids from result.
    $ids = array_keys($result[$entity_type]);
    // Load entities using ids.
    $entities = entity_load($entity_type, $ids, array(), TRUE);
    foreach ($entities as $entity) {
      $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);

      // Check the source field for value.
      if ($append
        && isset($entity_wrapper->$source_field_name)
        && $entity_wrapper->$source_field_name->value()
      ) {
        // Append the data.
        $newdata = array_merge($entity_wrapper->$destination_field_name->value(), $entity_wrapper->$source_field_name->value());
        // Set the new data.
        $entity_wrapper->$destination_field_name = $newdata;
        // If our clear parameter is true, we have to delete the old data.
        if ($clear) {
          $entity_wrapper->$source_field_name = NULL;
        }
        // And save the entity.
        $entity_wrapper->save();
      }
      elseif (
        isset($entity_wrapper->$source_field_name)
        && $entity_wrapper->$source_field_name->value()
        && $entity_wrapper->$destination_field_name->value() == NULL
      ) {
        // Same cardinality.
        if ($source_field_is_multiple == $destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = $entity_wrapper->$source_field_name->value();
        }
        // Source is multiple field, but destination not,
        // than take the first element.
        elseif ($source_field_is_multiple && !$destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = reset($entity_wrapper->$source_field_name->value());
        }
        // Source is single element field, but destination not,
        // than use an array wrapper.
        else {
          // Take the first item of array.
          $entity_wrapper->$destination_field_name = array($entity_wrapper->$source_field_name->value());
        }
        // If our clear parameter is true, we have to delete the old data.
        if ($clear) {
          $entity_wrapper->$source_field_name = NULL;
        }
        // Save the entity.
        $entity_wrapper->save();
      }
    }
  }
}

/**
 * Get the final content language after applying translations and fallbacks.
 *
 * @param object $node
 *   The node object to get the language for.
 *
 * @return string
 *   The language of the content.
 */
function _dt_shared_functions_content_language($node) {
  // Load potential relevant languages in the correct fallback order.
  $content_language_order = _dt_shared_functions_content_language_order();
  $content_language = $node->language;
  // Find first available translation that is applicable.
  if (!empty($content_language_order)) {
    foreach ($content_language_order as $language_code) {
      $translation = entity_translation_get_existing_language('node', $node, $language_code);
      // We have a translation so lets use it.
      if ($translation == $language_code) {
        $content_language = $language_code;
        break;
      }
      $content_language = $translation;
    }
  }

  return $content_language;
}

/**
 * Get the languages that are applicable in the right order of fallback.
 *
 * @return array
 *   List of languages in their order.
 */
function _dt_shared_functions_content_language_order() {
  global $language;
  // Get the first few languages of our fallback array. If we have a 2nd
  // language parameter set, we have to work with an additional language. If
  // not, we only need one.
  // Set our maximum languages to check.
  $max_languages = 1;
  // First we get our url parameters.
  $parameters = drupal_get_query_parameters();
  // Check if the 2nd-language parameter is set.
  if (isset($parameters['2nd-language']) && $parameters['2nd-language'] !== 'en') {
    // Extend maximum to include the 2nd-language.
    $max_languages = 2;
  }
  // Get the maximum extra languages.
  $fallback_languages = array_slice(language_fallback_get_candidates(), 0, $max_languages);
  // Add our current site language to the array.
  if (!in_array($language->language, $fallback_languages)) {
    array_unshift($fallback_languages, $language->language);
  }
  else {
    // Our default language is in the array but might not be the first. So we
    // move it.
    // Get the key of the language.
    $main_language_key = array_search($language->language, $fallback_languages);
    // Store it temporary.
    $prepend_language = $fallback_languages[$main_language_key];
    // Remove the item.
    unset($fallback_languages[$main_language_key]);
    // Then add it to the front.
    array_unshift($fallback_languages, $prepend_language);
  }

  return $fallback_languages;
}

/**
 * Removing 2 conflicting theme settings.
 */
function _dt_shared_functions_disable_anchors() {
  $dt_themes = ['information', 'political', 'europa', 'commissioner'];
  foreach ($dt_themes as $theme) {
    // Target correct variable.
    $target_settings = 'theme_' . $theme . '_settings';
    // Get the current settings.
    $theme_settings = variable_get($target_settings, FALSE);
    // If settings are not there, configure it, otherwise adapt them.
    if (!$theme_settings) {
      $theme_settings = array(
        'bootstrap_anchors_fix' => 0,
        'bootstrap_anchors_smooth_scrolling' => 0,
      );
    }
    else {
      $theme_settings['bootstrap_anchors_fix'] = 0;
      $theme_settings['bootstrap_anchors_smooth_scrolling'] = 0;
    }

    // Store the settings again.
    variable_set($target_settings, $theme_settings);
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * This is used to make this module load later in the bootstrap process.
 */
function dt_shared_functions_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'field_language_alter' && isset($implementations['dt_shared_functions'])) {
    $group = $implementations['dt_shared_functions'];
    unset($implementations['dt_shared_functions']);
    $implementations['dt_shared_functions'] = $group;
  }
}

/**
 * Helper function to get the readable language from a language code.
 *
 * @param string $langcode
 *   The langcode to get the language object for.
 *
 * @return object
 *   The language object.
 */
function _dt_shared_functions_get_language_obj($langcode, $type = 'name') {
  $languages = locale_language_list($type);

  return isset($languages[$langcode]) ? $languages[$langcode] : NULL;
}

/**
 * Implements hook_field_language_alter().
 *
 * Alters the language of translatable fields to be forced to use the content
 * language. This makes sure the content only shows the language requested,
 * except for the entity reference fields (or other non language aware fields).
 */
function dt_shared_functions_field_language_alter(&$display_language, $context) {
  if (variable_get('locale_field_language_fallback', TRUE) && $context['entity_type'] == 'node' && entity_translation_enabled($context['entity_type'])) {
    // Define our content language.
    $content_language = $context['language'];
    // Overwrite it if we manage to get a different content language.
    if ($lang = entity_translation_get_existing_language($context['entity_type'], $context['entity'])) {
      $content_language = $lang;
    }
    // To reduce load, we only do it for the current node. We dont use the
    // menu_get_object('node') here to save some resources, instead we use and
    // check the arg().
    $entity_nid = is_numeric(arg(1)) ? arg(1) : FALSE;
    // Make the checks.
    if ($entity_nid && $entity_nid == $context['entity']->nid) {
      // Loop over the fields being displayed.
      foreach ($display_language as $field_name => &$field_language) {
        // If the field language is not the same as the content, but is set to
        // be translatable, we set it to the content language.
        if ($field_language <> $content_language && $field_info = field_info_field($field_name)) {
          // We have field information, let's make our checks.
          if ($field_info['translatable']) {
            $field_language = $context['language'];
          }
        }
      }
    }
  }
}

/**
 * Helper function for contact phone fields.
 *
 * This function returns an array that will help
 * in validation/visualization of parts of
 * phone number number fields.
 *
 * @param string $label
 *   Field label, shoud display at errors.
 *
 * @return array
 *   Available patterns.
 */
function _dt_shared_functions_contactphone_patterns($label) {
  $patterns = array(
    'phone_label' => array(
      'pattern' => '/\s?\(([^)]+)\)$/',
      'return_key' => 0,
    ),
    'country_prefix' => array(
      'pattern' => '/^(\+[0-9]{2,3}\s?)/',
      'return_key' => 0,
      'required' => TRUE,
      'explain' => t('Country code missing or in wrong format, ex:+32'),
    ),
    'telephone' => array(
      'pattern' => '/^(\+[0-9]{2,3}\s+)((([0-9]{1,4})\s?)+)(\s?\(([^)]+)\))?$/',
      'return_key' => 2,
      'required' => 1,
      'explain' => t('@label is missing or with wrong format (+cc r xxx xx xx (description))', ['@label' => $label]),
    ),
  );
  return $patterns;
}

/**
 * Generates "<a href=tel:" tag for the contact phone field.
 *
 * If in the generation it fails it will return false.
 *
 * @param string $label
 *   Field label, shoud display at errors.
 * @param string $tel
 *   String containing phone number.
 *
 * @return string
 *   Returns formatted value or the source one.
 */
function dt_shared_function_phonetohtml($label, $tel) {
  $data = trim($tel);
  // Load the array containing our regular expressions and loop to convert them
  // into a link.
  foreach (_dt_shared_functions_contactphone_patterns($label) as $regexp_index => $regexp_values) {
    preg_match($regexp_values['pattern'], $data, $matches);
    // Something is wrong with the phone value and can't be displayed correctly.
    if (!isset($matches[$regexp_values['return_key']]) && isset($regexp_values['required'])) {
      return $tel;
    }
    else {
      if (isset($matches[$regexp_values['return_key']])) {
        $phone[$regexp_index] = trim($matches[$regexp_values['return_key']]);
      }
      else {
        $phone[$regexp_index] = '';
      }
    }
  }

  // Create the href tel: value.
  $tel = 'tel:' . str_replace(' ', '', $phone['country_prefix'] . $phone['telephone']);
  // This defines the element telephone in the component field.
  $classes = array('class' => 'field__telephone');
  // This will be the link title.
  $title = $phone['country_prefix'] . ' ' . $phone['telephone'];
  // Build the link.
  $htmlphone = l($title, $tel, array('attributes' => $classes));
  // The full element.
  $markup = $htmlphone . ' ' . $phone['phone_label'];

  return $markup;
}

/**
 * Implements hook_form_alter().
 */
function dt_shared_functions_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'system_theme_settings') {
    // Build the form.
    $form['dt'] = array(
      '#type' => 'fieldset',
      '#title' => t('DTT settings'),
      '#weight' => -100,
    );

    $form['dt']['dt_latest_visibility'] = array(
      '#type' => 'checkbox',
      '#title' => t('Would you like to show the latest block when it is available?'),
      '#default_value' => variable_get('dt_shared_functions_dt_latest_visibility', TRUE),
    );

    $form['#submit'][] = "_dt_shared_functions_theme_settings_submit";
  }
}

/**
 * Custom submit function for the theme setting form.
 */
function _dt_shared_functions_theme_settings_submit(&$form, &$form_state) {
  $override = $form_state['values']['dt_latest_visibility'] == 1 ? TRUE : FALSE;
  variable_set('dt_shared_functions_dt_latest_visibility', $override);
}
