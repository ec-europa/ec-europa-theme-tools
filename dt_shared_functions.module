<?php
/**
 * @file
 * This file contains the shared functions between dt_core and cwt_core.
 */

/**
 * No source field Exception.
 */
class DtSharedSourceFieldError extends Exception {
}

/**
 * No destionation field Exception.
 */
class DtSharedDestinationFieldError extends Exception {
}

/**
 * Fields are of same tye Exception.
 */
class DtSharedFieldTypeAreNotSame extends Exception {
}

/**
 * Circular reference Exception.
 */
class DtParentCircular extends Exception {
}

/**
 * Implements hook_token_info().
 */
function dt_shared_functions_token_info() {
  $token_info = array();
  nexteuropa_token_get_handler('language_handler')->hookTokenInfoAlter($token_info);
  return $token_info;
}

/**
 * Implements hook_nexteuropa_token_token_handlers().
 */
function dt_shared_functions_nexteuropa_token_token_handlers() {
  return array(
    'language_handler' => '\Drupal\dt_shared_functions\LanguageTokenHandler',
  );
}

/**
 * Implements hook_translated_menu_link_alter().
 */
function dt_shared_functions_translated_menu_link_alter(&$item, $map) {
  global $language;
  $tokenize = isset($item['options']['menu_token_data']['node']['options']['id']);

  if ($tokenize) {
    $nid = $item['options']['menu_token_data']['node']['options']['id'];
    $data['node'] = entity_load_single('node', $nid);
    // This should be done by the token_menu module, actually.
    $options['language'] = $language;
    $item['link_title'] = token_replace($item['title'], $data, $options);
  }
}

/**
 * Helper function to delete menu, menu links, taxonomies.
 */
function _dt_shared_functions_delete($name, $type = 'menu', $op = 'items') {
  switch ($type) {
    case 'menu':
      if ($op == 'items') {
        menu_delete_links($name);
      }
      else {
        menu_delete(array('menu_name' => $name));
      }
      break;

    case 'vocabulary':
      if ($op == 'items') {
        $voc = taxonomy_vocabulary_machine_name_load($name);
        if (!empty($voc)) {
          $terms = taxonomy_get_tree($voc->vid);
          foreach ($terms as $term) {
            taxonomy_term_delete($term->tid);
          }
        }
      }
      else {
        $voc = taxonomy_vocabulary_machine_name_load($name);
        if (!empty($voc)) {
          taxonomy_vocabulary_delete($voc->vid);
        }
      }
      break;

    case 'node':
      $node_type = array($name);
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'node')
        ->propertyCondition('type', $node_type, 'IN');
      $result = $query->execute();
      foreach ($result['node'] as $node) {
        node_delete($node->nid);
      }
      break;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Alters the exposed form to include some additional logic.
 */
function dt_shared_functions_form_views_exposed_form_alter(&$form, &$form_state) {
  if (!$form_state['submitted']) {
    // Hide the button, but only when js is available.
    if (isset($form['reset']) && !empty($form['reset'])) {
      $form['reset']['#attributes']['class'][] = 'js-hide';
      $form['reset']['#attributes']['class'][] = 'js-showonsubmit';
    }
  }
}

/**
 * Implements hook_ajax_render_alter().
 *
 * Hide the showonsubmit button after the ajax request.
 */
function dt_shared_functions_ajax_render_alter(&$commands) {
  $commands[] = ajax_command_invoke('.js-showonsubmit', 'show');
}


/**
 * Copy values from source to destination filed.
 *
 * @param string $entity_type
 *   The type of entity, like: node.
 * @param string $bundle
 *   Entity bundle, like: page.
 * @param string $source_field_name
 *   Source field name, like: field_core_link.
 * @param string $destination_field_name
 *   Destination field, like: field_core_links.
 *
 * @throws \DtSharedSourceFieldError
 *   Exception when no source field with the given name.
 * @throws \DtSharedDestinationFieldError
 *   Exception when no destination field with the given name.
 * @throws \DtSharedFieldTypeAreNotSame
 *   Exception when source and destination are not the same field type.
 */
function _dt_shared_field_value_copy($entity_type, $bundle, $source_field_name, $destination_field_name) {
  // Source and destination field info.
  $source_field_info = field_info_field($source_field_name);
  $destination_field_info = field_info_field($destination_field_name);

  // Error handling.
  if (!$source_field_info) {
    throw new DtSharedSourceFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $source_field_name,
      ))
    );
  }
  if (!$destination_field_info) {
    throw new DtSharedDestinationFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $destination_field_name,
      ))
    );
  }
  if ($source_field_info['type'] != $destination_field_info['type']) {
    throw new DtSharedFieldTypeAreNotSame(
      t('%source (source) and %destination (destination) are not the same field type.', array(
        '%source' => $source_field_name,
        '%destination' => $destination_field_name,
      ))
    );
  }
  // Source field  is a multiple one.
  $source_field_is_multiple = ($source_field_info['cardinality'] != 1) ? TRUE : FALSE;
  // Destination field is a multiple one.
  $destination_field_is_multiple = ($destination_field_info['cardinality'] != 1) ? TRUE : FALSE;

  // Query the entities.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $bundle);
  $result = $query->execute();

  // Use the result if any.
  if (isset($result[$entity_type])) {
    // Get the entity ids from result.
    $ids = array_keys($result[$entity_type]);
    // Load entities using ids.
    $entities = entity_load($entity_type, $ids, array(), TRUE);
    foreach ($entities as $entity) {
      $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);

      // Check the source field for value.
      if (
        isset($entity_wrapper->$source_field_name)
        && $entity_wrapper->$source_field_name->value()
        && $entity_wrapper->$destination_field_name->value() == NULL
      ) {
        // Same cardinality.
        if ($source_field_is_multiple == $destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = $entity_wrapper->$source_field_name->value();
        }
        // Source is multiple field, but destination not,
        // than take the first element.
        elseif ($source_field_is_multiple && !$destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = reset($entity_wrapper->$source_field_name->value());
        }
        // Source is single element field, but destination not,
        // than use an array wrapper.
        else {
          // Take the first item of array.
          $entity_wrapper->$destination_field_name = array($entity_wrapper->$source_field_name->value());
        }
        $entity_wrapper->save();
      }
    }
  }
}

/**
 * Helper: fixes the language of a field.
 *
 * @param string $field_name
 *   Machine name of field.
 */
function _dt_shared_fix_field_language($field_name) {
  // Default language.
  $language_default = language_default()->language;
  // Table names for update.
  $table_names = array(
    "field_data_$field_name",
    "field_revision_$field_name",
  );
  foreach ($table_names as $table_name) {
    $query = "
      UPDATE
        $table_name AS field_data
        INNER JOIN (
          SELECT
            entity_id
          FROM
            $table_name
          GROUP BY
            entity_id
          HAVING
            count(*) = 1
        ) AS filter ON filter.entity_id = field_data.entity_id
      SET
        language = '$language_default'
      WHERE
        language = 'und';
    ";
    db_query($query);
  }
}

/**
 * Get the final content language after applying translations and fallbacks.
 */
function _dt_shared_functions_content_language($node) {
  // Load potential relevant languages in the correct fallback order.
  $content_language_order = _dt_shared_functions_content_language_order();
  $content_language = $node->language;
  // Find first available translation that is applicable.
  if (!empty($content_language_order)) {
    foreach ($content_language_order as $language_code) {
      $translation = entity_translation_get_existing_language('node', $node, $language_code);
      // We have a translation so lets use it.
      if ($translation == $language_code) {
        $content_language = $language_code;
        break;
      }
      $content_language = $translation;
    }
  }

  return $content_language;
}

/**
 * Get the languages that are applicable in the right order of fallback.
 */
function _dt_shared_functions_content_language_order() {
  global $language;
  // Get the first few languages of our fallback array. If we have a 2nd
  // language parameter set, we have to work with an additional language. If
  // not, we only need one.
  // Set our maximum languages to check.
  $max_languages = 1;
  // First we get our url parameters.
  $parameters = drupal_get_query_parameters();
  // Check if the 2nd-language parameter is set.
  if (isset($parameters['2nd-language']) && $parameters['2nd-language'] !== 'en') {
    // Extend maximum to include the 2nd-language.
    $max_languages = 2;
  }
  // Get the maximum extra languages.
  $fallback_languages = array_slice(language_fallback_get_candidates(), 0, $max_languages);
  // Add our current site language to the array.
  if (!in_array($language->language, $fallback_languages)) {
    array_unshift($fallback_languages, $language->language);
  }
  else {
    // Our default language is in the array but might not be the first. So we
    // move it.
    // Get the key of the language.
    $main_language_key = array_search($language->language, $fallback_languages);
    // Store it temporary.
    $prepend_language = $fallback_languages[$main_language_key];
    // Remove the item.
    unset($fallback_languages[$main_language_key]);
    // Then add it to the front.
    array_unshift($fallback_languages, $prepend_language);
  }

  return $fallback_languages;
}

/**
 * Removing 2 conflicting theme settings.
 */
function _dt_shared_functions_disable_anchors() {
  $dt_themes = ['information', 'political', 'europa', 'commissioner'];
  foreach ($dt_themes as $theme) {
    // Target correct variable.
    $target_settings = 'theme_' . $theme . '_settings';
    // Get the current settings.
    $theme_settings = variable_get($target_settings, FALSE);
    // If settings are not there, configure it, otherwise adapt them.
    if (!$theme_settings) {
      $theme_settings = array(
        'bootstrap_anchors_fix' => 0,
        'bootstrap_anchors_smooth_scrolling' => 0,
      );
    }
    else {
      $theme_settings['bootstrap_anchors_fix'] = 0;
      $theme_settings['bootstrap_anchors_smooth_scrolling'] = 0;
    }

    // Store the settings again.
    variable_set($target_settings, $theme_settings);
  }
}

/**
 * Implements hook_module_implements_alter().
 *
 * This is used to make this module load later in the bootstrap process.
 */
function dt_shared_functions_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'field_language_alter' && isset($implementations['dt_shared_functions'])) {
    $group = $implementations['dt_shared_functions'];
    unset($implementations['dt_shared_functions']);
    $implementations['dt_shared_functions'] = $group;
  }
}

/**
 * Helper function to get the readable language from a language code.
 */
function _dt_shared_functions_get_language_obj($langcode) {
  $languages = locale_language_list();

  return isset($languages[$langcode]) ? $languages[$langcode] : NULL;
}

/**
 * Implements hook_field_language_alter().
 *
 * Alters the language of translatable fields to be forced to use the content
 * language. This makes sure the content only shows the language requested,
 * except for the entity reference fields (or other non language aware fields).
 */
function dt_shared_functions_field_language_alter(&$display_language, $context) {
  if (variable_get('locale_field_language_fallback', TRUE) && $context['entity_type'] == 'node' && entity_translation_enabled($context['entity_type'])) {
    // Define our content language.
    $content_language = $context['language'];
    // Overwrite it if we manage to get a different content language.
    if ($lang = entity_translation_get_existing_language($context['entity_type'], $context['entity'])) {
      $content_language = $lang;
    }
    // To reduce load, we only do it for the current node. We dont use the
    // menu_get_object('node') here to save some resources, instead we use and
    // check the arg().
    $entity_nid = is_numeric(arg(1)) ? arg(1) : FALSE;
    // Make the checks.
    if ($entity_nid && $entity_nid == $context['entity']->nid) {
      // Loop over the fields being displayed.
      foreach ($display_language as $field_name => &$field_language) {
        // If the field language is not the same as the content, but is set to
        // be translatable, we set it to the content language.
        if ($field_language <> $content_language && $field_info = field_info_field($field_name)) {
          // We have field information, let's make our checks.
          if ($field_info['translatable']) {
            $field_language = $context['language'];
          }
        }
      }
    }
  }
}

/**
 * Helper function for contact phone fields.
 *
 * This function returns an array that will help
 * in validation/visualization of parts of
 * phone number number fields.
 *
 * @return array
 *   return arrays
 */
function _dt_shared_functions_contactphone_patterns() {
  $patterns = array(
    'phone_label' => array(
      'pattern' => '/\s?\(([^)]+)\)$/',
      'return_key' => 0,
    ),
    'country_prefix' => array(
      'pattern' => '/^(\+[0-9]{2,3}\s?)/',
      'return_key' => 0,
      'required' => TRUE,
      'explain' => 'Country code missing or in wrong format, ex:+32',
    ),
    'telephone' => array(
      'pattern' => '/^(\+[0-9]{2,3}\s?)((([0-9]{1,4})\s?)+)(\s?\(([^)]+)\))?$/',
      'return_key' => 2,
      'required' => 1,
      'explain' => 'Phone number is missing or with wrong format (+cc r xxx xx xx (description))',
    ),
  );
  return $patterns;
}

/**
 * Generates "<a href=tel:" tag for the contact phone field.
 *
 * If in the generation it fails it will return false.
 *
 * @param string $tel
 *   String containing phone number.
 *
 * @return array|bool
 *   Returns string or False.
 */
function dt_shared_function_phonetohtml($tel) {
  $data = trim($tel);
  foreach (_dt_shared_functions_contactphone_patterns() as $pattern => $pattern_values) {
    preg_match($pattern_values['pattern'], $data, $matches);
    // Something is wrong with the phone value and can't be displayed correctly.
    if (!isset($matches[$pattern_values['return_key']]) && isset($pattern_values['required'])) {
      return FALSE;
    }
    else {
      if (isset($matches[$pattern_values['return_key']])) {
        $phone[$pattern] = trim($matches[$pattern_values['return_key']]);
      }
      else {
        $phone[$pattern] = '';
      }
    }
  }
  // Create the href tag with phone link.
  $htmlphone = '<a href="tel:' . str_replace(' ', '', $phone['country_prefix'] . $phone['telephone']) . '">'
    . $phone['country_prefix'] . ' ' . $phone['telephone'] . '</a> ' . $phone['phone_label'];

  return $htmlphone;
}

/**
 * Helper function to create translations from source.
 */
function _dt_shared_function_copy_translation() {
  $fields_to_fix = array(
    'departments' => array(
      'source' => 'Departments',
      'target' => 'Related departments',
      'source_context' => '',
      'target_context' => '',
    ),
    'topics' => array(
      'source' => 'Topics',
      'target' => 'Related topics',
      'source_context' => '',
      'target_context' => '',
    ),
    'timeline' => array(
      'source' => 'Show timeline',
      'target' => 'Show all timeline',
      'source_context' => '',
      'target_context' => '',
    ),
    'responsibilities' => array(
      'source' => 'Responsibilities',
      'target' => 'Responsibilities',
      'source_context' => '',
      'target_context' => 'body:biography:label',
    ),
    'team' => array(
      'source' => 'Team',
      'target' => 'Team',
      'source_context' => '',
      'target_context' => '',
    ),
    'team-page' => array(
      'source' => 'team page',
      'target' => 'Team page',
      'source_context' => '',
      'target_context' => '',
    ),
  );

  foreach ($fields_to_fix as $key => $field) {

    // Get the target_id.
    $query_1 = "SELECT lid FROM locales_source WHERE source='" . $field['target'] . "' AND context='" . $field['target_context'] . "'";
    $result_1 = db_query($query_1);
    if (count($result_1) == 1) {
      foreach ($result_1 as $record) {
        $target_id = $record->lid;
      }

      // Get the source_id.
      $query_2 = "SELECT lid FROM locales_source WHERE source='" . $field['source'] . "' AND context='" . $field['source_context'] . "'";
      $result_2 = db_query($query_2);
      if (count($result_2) == 1) {
        foreach ($result_2 as $record) {
          $source_id = $record->lid;
        }

        $query_3 = "SELECT * FROM locales_target WHERE lid = $target_id";
        $result_3 = db_query($query_3);
        $counter = 0;
        foreach ($result_3 as $key) {
          $counter++;
        }

        if ($counter == 0) {
          $query_4 = "SELECT * FROM locales_target WHERE lid = $source_id";
          $result_4 = db_query($query_4);
          foreach ($result_4 as $record) {
            $translation = addslashes($record->translation);
            $insert_query = "INSERT INTO
          locales_target
          (lid, translation, language)
          VALUES
          ($target_id, '$translation', '$record->language')";
            db_query($insert_query);
            $insert_query = NULL;
          }
        }
      }
    }
    unset($result);
    unset($query);
  }
}
